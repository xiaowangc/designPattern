装饰者模式可以在不改变原本基本行为的基础上，进行功能的扩展
特点：单一职责原则：可理解为将小的功能封装成方法，便于复用

### 四个重要的类：
1.组件接口Component接口相当于汽车接口，所有的被包装类、包装类，都继承于这个接口。      

2.具体组件ConcreteComponent类：是被包装的实现类。
  在例子中，奔驰汽车、宝马汽车、特斯拉汽车都属于这个角色

3.装饰基类BaseDecorator：所有的包装类，都继承自BaseDecorator抽象类，而BaseDecorator类又实现了Component接口，
  这么做是为了实现多层嵌套包装

4.具体装饰类ConcreteDecorator：用于扩充被包装类的功能，比如例子中的自动驾驶功能、飞行功能扩展。
  每新增一个功能，就需要增加一个具体装饰类
##实现方式

1.确保业务逻辑可用一个基本组件及多个额外可选层次表示。

2.找出<基本组件>和可选层次的<通用方法>。 创建一个组件接口并在其中声明这些方法。

3.创建一个具体组件类ConcreteComponent， 并定义其基础行为。

4.创建装饰基类BaseDecorator， 使用一个成员变量存储指向被封装对象的引用.
  该成员变量必须被声明为组件接口类型<Component接口> ， 从而能在运行时连接具体组件和装饰。 
  装饰基类必须将所有工作委派给被封装的对象<Component接口>。

5.确保所有类实现组件接口。

6.将装饰基类扩展为具体装饰<ConcreteDecorator>。 具体装饰必须在调用父类方法 （总是委派给被封装对象） 之前或之后执行自身的行为。

7.客户端代码负责创建装饰并将其组合成客户端所需的形式。